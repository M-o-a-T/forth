#!/usr/bin/python3

#
# This script generates a peripheral device map.
#
# SPDX-License-Identifier: GPL-3.0-only

import re
import sys
import click
import xml.etree.ElementTree as ET

version = "0.1"

def unknown(x):
    raise ValueError(x)

_ws = re.compile(r"[\n \t]+")
def unws(txt):
    if txt is None:
        return ""
    return _ws.sub(" ",txt.text)

def txt_if(txt):
    if txt is None:
        return
    return txt.text

def unhex(txt):
    if txt is None:
        return
    return int(txt.text, 16)

def acc(f):
    if f is not None:
        return 3 if f.text == "read-write" else 2 if f.text == "write-only" else 1 if f.text == "read-only" else unknown(acc.text)

@click.command()
@click.option("-v","--voc",help="Put the words in this vocabulary (must exist)", default="forth")
@click.argument("args", nargs=-1)
@click.pass_context
def main(ctx, args, **kw):
    """\
        Create a ARM register map description as Forth code from an ARM
        description.

        Arguments:

        * the *.SVD file for your CPU, or your Cortex core
          (you need both)

        * the register groups to print

        If you only specify the SVD file, a list of available register groups is
        printed.

    """
    if not args:
        print(ctx.get_help(), file=sys.stderr)
        sys.exit(2)

    r = ET.parse(args[0]).getroot()
    rp = r.find("peripherals")

    if len(args) == 1:
        seen = set()
        for p in rp.iterfind("peripheral"):
            if "derivedFrom" in p.attrib:
                continue
            g = p.find("groupName")
            if g is None:
                g = p.find("name")
            if g.text in seen:
                continue
            print(g.text)
            seen.add(g.text)
        sys.exit(1)

    print(f"""\
\\ This file is auto-generated from {args[0]}.
\\ It contains registers for {"".join(args[1:])}
\\ Generator: mapgen {version}
""")
    if len(args) == 2 and args[1] == "*":
        gen(rp, **kw)
    else:
        gen(rp, set(args[1:]), **kw)

    print(f"""\

{kw["voc"]} definitions
#ok depth 0=

\ This file is auto-generated by "mapgen", part of MoaT Forth.
\ The generator states:
\ SPDX-License-Identifier: GPL-3.0-only
\ 
\ EOF
""")


devs = {}

class periph:
    par = None
    adr = None
    done = False

    def __init__(self, p):
        self.d = p
        self.name = p.find("name").text
        self.groupName = txt_if(p.find("groupName"))
        self.derivs = {}
        self.regs = {}

        self.analyze(p)

        devs[self.name] = self

    def __eq__(self, other):
        # willfully ignore anything other than regs
        return self.regs == other.regs

    def analyze(self,p):
        self.descr = unws(p.find("description"))
        self.adr = unhex(p.find("baseAddress"))
        rg = p.find("registers")
        if rg is not None:
            for r in rg.iterfind("register"):
                reg(r,self)

    def add_reg(self,r):
        self.regs[r.name] = r

    def add_deriv(self,d):
        self.derivs[d.name] = d

    def emit(self):
        if self.done:
            return
        self.done = True
        if self.par is not None:
            self.par.emit()
        if self.descr:
            print("")
            print(f"\\ {self.descr}")
        if self.par is None and not self.regs:
            print(f"  \\ {self.name}: no registers found")

        if self.par is None:
            print(f"_reg voc: _{self.name}")
        elif self.regs:
            print(f"_{self.par.name} voc: _{self.name}")
        print("")
        if self.regs:
            for r in self.regs.values():
                r.emit()
        if self.par is None or self.regs:
            print(f"    previous definitions \\ end {self.name}")

    def emit_port(self):
        if self.regs or self.par is None:
            n = self.name
        else:
            n = self.par.name
        print(f"${self.adr:08x} _{n} port: {self.name}")

    def derive_from(self, p):
        self.par = p
        self.par.add_deriv(self)


class reg:
    adr = None
    def __init__(self, p, g):
        self.d = p
        self.periph = g
        self.name = p.find("name").text

        self.fields = {}
        self.analyze(p)

        g.add_reg(self)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        return self.fields == other.fields

    def analyze(self, p):
        self.adr = unhex(p.find("addressOffset"))
        self.access = acc(p.find("access"))
        self.size = int(p.find("size").text,16)
        self.rgw = "" if self.size == 32 else str(self.size)

        self.descr = unws(p.find("description"))
        fl = p.find("fields")
        if fl is not None:
            for f in fl.iterfind("field"):
                field(f,self)

        self.single = False
        if len(self.fields) == 1:
            f = list(self.fields.values())[0]
            if f.width == self.size:
                self.single = True

    def add_field(self,f):
        self.fields[f.name] = f

    def emit(self):
        print("")
        print(f"\\ {self.name} : {self.descr}")
        if self.single:
            print(f"  &rg{self.rgw} item")
        else:
            # check if there's an existing register file to recycle
            for dd in devs.values():
                if dd is self.periph:
                    continue
                if not dd.done:
                    continue
                for rr in dd.regs.values():
                    if rr == self:
                        print(f"  _{dd.name} _{rr.name} item")
                        print(f"${self.adr:x} offset: {self.name}")
                        return

            print(f"  &rg{self.rgw} voc: _{self.name}")
            for f in self.fields.values():
                f.emit()
            print("        previous definitions")
            print(f"  _{self.name} item")
        print("")
        print(f"${self.adr:x} offset: {self.name}")


class field:
    def __init__(self, p, r):
        self.d = p
        self.reg = r
        self.analyze(p)

        r.add_field(self)

    def __eq__(self, other):
        if self.offset != other.offset:
            return False
        if self.width != other.width:
            return False
        return self.name == other.name

    def analyze(self, p):
        self.name = p.find("name").text
        self.descr = unws(p.find("description"))
        self.offset = int(p.find("bitOffset").text)
        self.width = int(p.find("bitWidth").text)

    def emit(self):
        fa = self.d.find("access")
        if fa is None:
            fa = acc
        else:
            fa = 3 if fa.text == "read-write" else 2 if fa.text == "write-only" else 1 if fa.text == "read-only" else unknown(fa.text)

        if self.width == 1:
            print(f"        &bi{self.reg.rgw} item \\ {self.offset}\n    ${self.offset} constant {self.name} \\ {self.descr}")
        else:
            print(f"        &bf{self.reg.rgw} item \\ {self.width+self.offset-1}:{self.offset}\n    ${(self.width<<5)+self.offset:x} constant {self.name} \\ {self.descr}")


def gen(rp, names=(), voc=None, **kw):
    global devs
    global done

    print("bits only definitions")
    print("")

    devs = {}

    for p in rp.iterfind("peripheral"):
        if "derivedFrom" in p.attrib:
            continue
        gn = p.find("groupName")
        periph(p)

    for p in rp.iterfind("peripheral"):
        mn = p.attrib.get("derivedFrom", None)
        if mn is None:
            continue
        master = devs.get(mn, None)
        if master is None:
            continue
        dev = periph(p)
        dev.derive_from(master)

    for d in devs.values():
        if names and d.groupName not in names:
            continue
        d.emit(**kw)
        for dd in d.derivs.values():
            dd.emit(**kw)

    for d in devs.values():
        if names and d.name not in names:
            continue
        d.emit(**kw)

    print("")
    print(f"  {voc} definitions")
    print("")

    for d in devs.values():
        if not d.done:
            continue
        d.emit_port()

    print("")
    print("  bits ignore")



if __name__ == "__main__":
    main()

# EOF

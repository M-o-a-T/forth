#!/usr/bin/python3

#
# This script generates a peripheral device map.
#
# SPDX-License-Identifier: GPL-3.0-only

import re
import sys
import click
import xml.etree.ElementTree as ET

version = "0.1"

def unknown(x):
    raise ValueError(x)

_ws = re.compile(r"[\n \t]+")
def unws(txt):
    if txt is None:
        return ""
    return _ws.sub(" ",txt.text)

def unhex(txt):
    if txt is None:
        return
    return int(txt.text, 16)

def acc(f):
    if f is not None:
        return 3 if f.text == "read-write" else 2 if f.text == "write-only" else 1 if f.text == "read-only" else unknown(acc.text)

@click.command()
@click.option("-v","--voc",help="Put the words in this vocabulary (must exist)", default="forth")
@click.argument("args", nargs=-1)
@click.pass_context
def main(ctx, args, voc, **kv):
    """\
        Create a ARM register map description as Forth code from an ARM
        description.

        Arguments:

        * the *.SVD file for your CPU, or your Cortex core
          (you need both)

        * the register groups to print

        If you only specify the SVD file, a list of available register groups is
        printed.

    """
    if not args:
        print(ctx.get_help(), file=sys.stderr)
        sys.exit(2)

    r = ET.parse(args[0]).getroot()
    rp = r.find("peripherals")

    if len(args) == 1:
        seen = set()
        for p in rp.iterfind("peripheral"):
            if "derivedFrom" in p.attrib:
                continue
            g = p.find("groupName")
            if g is None:
                g = p.find("name")
            if g.text in seen:
                continue
            print(g.text)
            seen.add(g.text)
        sys.exit(1)

    print(f"""\
\\ This file is auto-generated from {args[0]}.
\\ It contains registers for {"".join(args[1:])}
\\ Generator: mapgen {version}

get-current

""")
    for pp in args[1:]:
        gen(rp, pp)

    print("""\

set-current
#ok depth 0=

\ This file is auto-generated by "mapgen", part of MoaT Forth.
\ The generator states:
\ SPDX-License-Identifier: GPL-3.0-only
\ 
\ EOF
""")


devs = {}

class periph:
    par = None
    adr = None

    def __init__(self, p):
        self.d = p
        self.name = p.find("name").text
        self.derivs = []
        self.regs = {}

        self.analyze(p)

        devs[self.name] = self

    def analyze(self,p):
        self.descr = unws(p.find("description"))
        self.adr = unhex(p.find("baseAddress"))
        rg = p.find("registers")
        if rg is not None:
            for r in rg.iterfind("register"):
                reg(r,self)

    def add_reg(self,r):
        self.regs[r.name] = r

    def add_deriv(self,d):
        self.derivs[r.name] = d

    def emit(self):
        print("")
        print(f"\\ {self.descr}")
        if self.par is None:
            print(f"_reg voc: _{self.name}")
        else:
            print(f"_{self.par.name} voc: _{self.name}")
        print("")
        if self.regs:
            for r in self.regs.values():
                r.emit()
            print("  dup set-current")
            print(f"${self.adr:08x} _{self.name} port: {self.name}")
        else:
            print(f"  \\ {self.name}: no registers found")

    def derive_from(p):
        self.par = p
        self.par.add_deriv(self)


class reg:
    adr = None
    def __init__(self, p, g):
        self.d = p
        self.periph = p
        self.name = p.find("name").text

        self.fields = {}
        self.analyze(p)

        g.add_reg(self)

    def analyze(self, p):
        self.adr = unhex(p.find("addressOffset"))
        self.access = acc(p.find("access"))
        self.size = int(p.find("size").text,16)
        self.rgw = "" if self.size == 32 else str(self.size)

        self.descr = unws(p.find("description"))
        fl = p.find("fields")
        if fl is not None:
            for f in fl.iterfind("field"):
                field(f,self)

        self.single = False
        if len(self.fields) == 1:
            f = list(self.fields.values())[0]
            if f.width == self.size:
                self.single = True

    def add_field(self,f):
        self.fields[f.name] = f

    def emit(self):
        print("")
        print(f"\\ {self.name} : {self.descr}")
        if self.single:
            print(f"  &rg{self.rgw} item")
        else:
            print(f"  &rg{self.rgw} voc: _{self.name}")
            for f in self.fields.values():
                f.emit()
            print("        previous definitions")
            print(f"  _{self.name} item")
        print("")
        print(f"${self.adr:x} offset: {self.name}")


class field:
    def __init__(self, p, r):
        self.d = p
        self.reg = r
        self.analyze(p)

        r.add_field(self)

    def analyze(self, p):
        self.name = p.find("name").text
        self.descr = unws(p.find("description"))
        self.offset = int(p.find("bitOffset").text)
        self.width = int(p.find("bitWidth").text)

    def emit(self):
        fa = self.d.find("access")
        if fa is None:
            fa = acc
        else:
            fa = 3 if fa.text == "read-write" else 2 if fa.text == "write-only" else 1 if fa.text == "read-only" else unknown(fa.text)

        if self.width == 1:
            print(f"        &bi{self.reg.rgw} item \\ {self.offset}\n    ${self.offset} constant {self.name} \\ {self.descr}")
        else:
            print(f"        &bf{self.reg.rgw} item \\ {self.width+self.offset-1}:{self.offset}\n    ${(self.width<<5)+self.offset:x} constant {self.name} \\ {self.descr}")


def gen(rp,name):
    global devs

    print("bits also definitions")
    print("")

    devs = {}

    for p in rp.iterfind("peripheral"):
        if "derivedFrom" in p.attrib:
            continue
        gn = p.find("groupName") or p.find("name")
        if gn.text != name:
            continue
        periph(p)

    for p in rp.iterfind("peripheral"):
        if p.find("group") != name:
            continue
        if "derivedFrom" not in p.attrib:
            continue
        master = devs[p.attrib["derivedFrom"]]
        dev = periph(p)
        dev.derive_from(master)

    def maybe_emit(d):
        if d.par is not None:
            return
        if d.adr is None:
            print("\\ ??? no address known")
        else:
            d.emit()

    for d in devs.values():
        maybe_emit(d)


if __name__ == "__main__":
    main()

